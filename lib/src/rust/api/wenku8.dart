// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../wenku8/models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

Future<void> wenku8Login({
  required String username,
  required String password,
  required String checkcode,
}) => RustLib.instance.api.crateApiWenku8Wenku8Login(
  username: username,
  password: password,
  checkcode: checkcode,
);

Future<List<BookshelfItem>> wenku8GetBookshelf() =>
    RustLib.instance.api.crateApiWenku8Wenku8GetBookshelf();

Future<bool> preLoginState() =>
    RustLib.instance.api.crateApiWenku8PreLoginState();

Future<void> logout() => RustLib.instance.api.crateApiWenku8Logout();

Future<Uint8List> downloadCheckcode() =>
    RustLib.instance.api.crateApiWenku8DownloadCheckcode();

Future<UserDetail> userDetail() =>
    RustLib.instance.api.crateApiWenku8UserDetail();

Future<List<HomeBlock>> index() => RustLib.instance.api.crateApiWenku8Index();

Future<String> downloadImage({required String url}) =>
    RustLib.instance.api.crateApiWenku8DownloadImage(url: url);

Future<String> chapterContent({required String aid, required String cid}) =>
    RustLib.instance.api.crateApiWenku8ChapterContent(aid: aid, cid: cid);

Future<NovelInfo> novelInfo({required String aid}) =>
    RustLib.instance.api.crateApiWenku8NovelInfo(aid: aid);

Future<List<Volume>> novelReader({required String aid}) =>
    RustLib.instance.api.crateApiWenku8NovelReader(aid: aid);

Future<void> updateHistory({
  required String novelId,
  required String novelName,
  required String volumeId,
  required String volumeName,
  required String chapterId,
  required String chapterTitle,
  required int progress,
  required int progressPage,
  required String cover,
  required String author,
}) => RustLib.instance.api.crateApiWenku8UpdateHistory(
  novelId: novelId,
  novelName: novelName,
  volumeId: volumeId,
  volumeName: volumeName,
  chapterId: chapterId,
  chapterTitle: chapterTitle,
  progress: progress,
  progressPage: progressPage,
  cover: cover,
  author: author,
);

Future<void> deleteAllHistory() =>
    RustLib.instance.api.crateApiWenku8DeleteAllHistory();

Future<ReadingHistory?> novelHistoryById({required String novelId}) =>
    RustLib.instance.api.crateApiWenku8NovelHistoryById(novelId: novelId);

Future<List<ReadingHistory>> listReadingHistory({
  required int offset,
  required int limit,
}) => RustLib.instance.api.crateApiWenku8ListReadingHistory(
  offset: offset,
  limit: limit,
);

Future<List<TagGroup>> tags() => RustLib.instance.api.crateApiWenku8Tags();

Future<PageStatsNovelCover> tagPage({
  required String tag,
  required String v,
  required int pageNumber,
}) => RustLib.instance.api.crateApiWenku8TagPage(
  tag: tag,
  v: v,
  pageNumber: pageNumber,
);

Future<PageStatsNovelCover> toplist({
  required String sort,
  required int page,
}) => RustLib.instance.api.crateApiWenku8Toplist(sort: sort, page: page);

Future<PageStatsNovelCover> articlelist({
  required int fullflag,
  required int page,
}) => RustLib.instance.api.crateApiWenku8Articlelist(
  fullflag: fullflag,
  page: page,
);

Future<void> addBookshelf({required String aid}) =>
    RustLib.instance.api.crateApiWenku8AddBookshelf(aid: aid);

Future<void> deleteBookcase({required String bid}) =>
    RustLib.instance.api.crateApiWenku8DeleteBookcase(bid: bid);

Future<List<Bookcase>> bookcaseList() =>
    RustLib.instance.api.crateApiWenku8BookcaseList();

Future<List<BookcaseItem>> bookInCase({required String caseId}) =>
    RustLib.instance.api.crateApiWenku8BookInCase(caseId: caseId);

Future<void> moveBookcase({
  required List<String> bidList,
  required String fromBookcaseId,
  required String toBookcaseId,
}) => RustLib.instance.api.crateApiWenku8MoveBookcase(
  bidList: bidList,
  fromBookcaseId: fromBookcaseId,
  toBookcaseId: toBookcaseId,
);

Future<List<SearchHistory>> searchHistories() =>
    RustLib.instance.api.crateApiWenku8SearchHistories();

Future<PageStatsNovelCover> search({
  required String searchType,
  required String searchKey,
  required int page,
}) => RustLib.instance.api.crateApiWenku8Search(
  searchType: searchType,
  searchKey: searchKey,
  page: page,
);

Future<bool> autoSign() => RustLib.instance.api.crateApiWenku8AutoSign();

Future<void> downloadNovel({
  required String aid,
  required List<String> cidList,
}) => RustLib.instance.api.crateApiWenku8DownloadNovel(
  aid: aid,
  cidList: cidList,
);

Future<List<NovelDownload>> allDownloads() =>
    RustLib.instance.api.crateApiWenku8AllDownloads();

Future<ExistsDownload?> existsDownload({required String novelId}) =>
    RustLib.instance.api.crateApiWenku8ExistsDownload(novelId: novelId);

Future<void> deleteDownload({required String novelId}) =>
    RustLib.instance.api.crateApiWenku8DeleteDownload(novelId: novelId);

Future<void> cleanAllWebCache() =>
    RustLib.instance.api.crateApiWenku8CleanAllWebCache();

Future<void> resetFailDownloads() =>
    RustLib.instance.api.crateApiWenku8ResetFailDownloads();

class ExistsDownload {
  final NovelDownload novelDownload;
  final List<NovelDownloadVolume> novelDownloadVolume;
  final List<NovelDownloadChapter> novelDownloadChapter;

  const ExistsDownload({
    required this.novelDownload,
    required this.novelDownloadVolume,
    required this.novelDownloadChapter,
  });

  @override
  int get hashCode =>
      novelDownload.hashCode ^
      novelDownloadVolume.hashCode ^
      novelDownloadChapter.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExistsDownload &&
          runtimeType == other.runtimeType &&
          novelDownload == other.novelDownload &&
          novelDownloadVolume == other.novelDownloadVolume &&
          novelDownloadChapter == other.novelDownloadChapter;
}

class NovelDownload {
  final String novelId;
  final String novelName;
  final int downloadStatus;
  final String coverUrl;
  final int coverDownloadStatus;
  final String author;
  final String tags;
  final int chooseChapterCount;
  final int downloadChapterCount;
  final PlatformInt64 createTime;
  final PlatformInt64 downloadTime;
  final String introduce;
  final String trending;
  final bool isAnimated;
  final String finUpdate;
  final String status;

  const NovelDownload({
    required this.novelId,
    required this.novelName,
    required this.downloadStatus,
    required this.coverUrl,
    required this.coverDownloadStatus,
    required this.author,
    required this.tags,
    required this.chooseChapterCount,
    required this.downloadChapterCount,
    required this.createTime,
    required this.downloadTime,
    required this.introduce,
    required this.trending,
    required this.isAnimated,
    required this.finUpdate,
    required this.status,
  });

  @override
  int get hashCode =>
      novelId.hashCode ^
      novelName.hashCode ^
      downloadStatus.hashCode ^
      coverUrl.hashCode ^
      coverDownloadStatus.hashCode ^
      author.hashCode ^
      tags.hashCode ^
      chooseChapterCount.hashCode ^
      downloadChapterCount.hashCode ^
      createTime.hashCode ^
      downloadTime.hashCode ^
      introduce.hashCode ^
      trending.hashCode ^
      isAnimated.hashCode ^
      finUpdate.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NovelDownload &&
          runtimeType == other.runtimeType &&
          novelId == other.novelId &&
          novelName == other.novelName &&
          downloadStatus == other.downloadStatus &&
          coverUrl == other.coverUrl &&
          coverDownloadStatus == other.coverDownloadStatus &&
          author == other.author &&
          tags == other.tags &&
          chooseChapterCount == other.chooseChapterCount &&
          downloadChapterCount == other.downloadChapterCount &&
          createTime == other.createTime &&
          downloadTime == other.downloadTime &&
          introduce == other.introduce &&
          trending == other.trending &&
          isAnimated == other.isAnimated &&
          finUpdate == other.finUpdate &&
          status == other.status;
}

class NovelDownloadChapter {
  final String id;
  final String title;
  final String url;
  final String aid;
  final String volumeId;
  final int downloadStatus;
  final int totalPicture;
  final int chapterIdx;

  const NovelDownloadChapter({
    required this.id,
    required this.title,
    required this.url,
    required this.aid,
    required this.volumeId,
    required this.downloadStatus,
    required this.totalPicture,
    required this.chapterIdx,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      title.hashCode ^
      url.hashCode ^
      aid.hashCode ^
      volumeId.hashCode ^
      downloadStatus.hashCode ^
      totalPicture.hashCode ^
      chapterIdx.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NovelDownloadChapter &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          title == other.title &&
          url == other.url &&
          aid == other.aid &&
          volumeId == other.volumeId &&
          downloadStatus == other.downloadStatus &&
          totalPicture == other.totalPicture &&
          chapterIdx == other.chapterIdx;
}

class NovelDownloadVolume {
  final String id;
  final String novelId;
  final int volumeIdx;
  final String title;
  final int downloadStatus;
  final PlatformInt64 createTime;

  const NovelDownloadVolume({
    required this.id,
    required this.novelId,
    required this.volumeIdx,
    required this.title,
    required this.downloadStatus,
    required this.createTime,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      novelId.hashCode ^
      volumeIdx.hashCode ^
      title.hashCode ^
      downloadStatus.hashCode ^
      createTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NovelDownloadVolume &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          novelId == other.novelId &&
          volumeIdx == other.volumeIdx &&
          title == other.title &&
          downloadStatus == other.downloadStatus &&
          createTime == other.createTime;
}

class PageStatsNovelCover {
  final int currentPage;
  final int maxPage;
  final List<NovelCover> records;

  const PageStatsNovelCover({
    required this.currentPage,
    required this.maxPage,
    required this.records,
  });

  static Future<PageStatsNovelCover> default_() =>
      RustLib.instance.api.crateApiWenku8PageStatsNovelCoverDefault();

  @override
  int get hashCode =>
      currentPage.hashCode ^ maxPage.hashCode ^ records.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PageStatsNovelCover &&
          runtimeType == other.runtimeType &&
          currentPage == other.currentPage &&
          maxPage == other.maxPage &&
          records == other.records;
}

class ReadingHistory {
  final String novelId;
  final String novelName;
  final String volumeId;
  final String volumeName;
  final String chapterId;
  final String chapterTitle;
  final PlatformInt64 lastReadAt;
  final int progress;
  final int progressPage;
  final String cover;
  final String author;

  const ReadingHistory({
    required this.novelId,
    required this.novelName,
    required this.volumeId,
    required this.volumeName,
    required this.chapterId,
    required this.chapterTitle,
    required this.lastReadAt,
    required this.progress,
    required this.progressPage,
    required this.cover,
    required this.author,
  });

  @override
  int get hashCode =>
      novelId.hashCode ^
      novelName.hashCode ^
      volumeId.hashCode ^
      volumeName.hashCode ^
      chapterId.hashCode ^
      chapterTitle.hashCode ^
      lastReadAt.hashCode ^
      progress.hashCode ^
      progressPage.hashCode ^
      cover.hashCode ^
      author.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReadingHistory &&
          runtimeType == other.runtimeType &&
          novelId == other.novelId &&
          novelName == other.novelName &&
          volumeId == other.volumeId &&
          volumeName == other.volumeName &&
          chapterId == other.chapterId &&
          chapterTitle == other.chapterTitle &&
          lastReadAt == other.lastReadAt &&
          progress == other.progress &&
          progressPage == other.progressPage &&
          cover == other.cover &&
          author == other.author;
}

class SearchHistory {
  final String searchType;
  final String searchKey;
  final PlatformInt64 searchTime;

  const SearchHistory({
    required this.searchType,
    required this.searchKey,
    required this.searchTime,
  });

  @override
  int get hashCode =>
      searchType.hashCode ^ searchKey.hashCode ^ searchTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SearchHistory &&
          runtimeType == other.runtimeType &&
          searchType == other.searchType &&
          searchKey == other.searchKey &&
          searchTime == other.searchTime;
}
