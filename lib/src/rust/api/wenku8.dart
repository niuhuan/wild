// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../wenku8/models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`

Future<void> wenku8Login({
  required String username,
  required String password,
  required String checkcode,
}) => RustLib.instance.api.crateApiWenku8Wenku8Login(
  username: username,
  password: password,
  checkcode: checkcode,
);

Future<List<BookshelfItem>> wenku8GetBookshelf() =>
    RustLib.instance.api.crateApiWenku8Wenku8GetBookshelf();

Future<bool> preLoginState() =>
    RustLib.instance.api.crateApiWenku8PreLoginState();

Future<Uint8List> downloadCheckcode() =>
    RustLib.instance.api.crateApiWenku8DownloadCheckcode();

Future<UserDetail> userDetail() =>
    RustLib.instance.api.crateApiWenku8UserDetail();

Future<List<HomeBlock>> index() => RustLib.instance.api.crateApiWenku8Index();

Future<String> downloadImage({required String url}) =>
    RustLib.instance.api.crateApiWenku8DownloadImage(url: url);

Future<String> chapterContent({required String aid, required String cid}) =>
    RustLib.instance.api.crateApiWenku8ChapterContent(aid: aid, cid: cid);

Future<NovelInfo> novelInfo({required String aid}) =>
    RustLib.instance.api.crateApiWenku8NovelInfo(aid: aid);

Future<List<Volume>> novelReader({required String aid}) =>
    RustLib.instance.api.crateApiWenku8NovelReader(aid: aid);

Future<void> updateHistory({
  required String novelId,
  required String novelName,
  required String volumeId,
  required String volumeName,
  required String chapterId,
  required String chapterTitle,
  required int progress,
  required String cover,
  required String author,
}) => RustLib.instance.api.crateApiWenku8UpdateHistory(
  novelId: novelId,
  novelName: novelName,
  volumeId: volumeId,
  volumeName: volumeName,
  chapterId: chapterId,
  chapterTitle: chapterTitle,
  progress: progress,
  cover: cover,
  author: author,
);

Future<ReadingHistory?> novelHistoryById({required String novelId}) =>
    RustLib.instance.api.crateApiWenku8NovelHistoryById(novelId: novelId);

Future<List<ReadingHistory>> listReadingHistory({
  required int offset,
  required int limit,
}) => RustLib.instance.api.crateApiWenku8ListReadingHistory(
  offset: offset,
  limit: limit,
);

Future<List<TagGroup>> tags() => RustLib.instance.api.crateApiWenku8Tags();

Future<PageStatsNovelCover> tagPage({
  required String tag,
  required String v,
  required int pageNumber,
}) => RustLib.instance.api.crateApiWenku8TagPage(
  tag: tag,
  v: v,
  pageNumber: pageNumber,
);

Future<PageStatsNovelCover> toplist({
  required String sort,
  required int page,
}) => RustLib.instance.api.crateApiWenku8Toplist(sort: sort, page: page);

Future<PageStatsNovelCover> articlelist({
  required int fullflag,
  required int page,
}) => RustLib.instance.api.crateApiWenku8Articlelist(
  fullflag: fullflag,
  page: page,
);

Future<void> addBookshelf({required String aid}) =>
    RustLib.instance.api.crateApiWenku8AddBookshelf(aid: aid);

Future<void> deleteBookcase({required String bid}) =>
    RustLib.instance.api.crateApiWenku8DeleteBookcase(bid: bid);

Future<List<Bookcase>> bookcaseList() =>
    RustLib.instance.api.crateApiWenku8BookcaseList();

Future<List<BookcaseItem>> bookInCase({required String caseId}) =>
    RustLib.instance.api.crateApiWenku8BookInCase(caseId: caseId);

Future<void> moveBookcase({
  required List<String> bidList,
  required String fromBookcaseId,
  required String toBookcaseId,
}) => RustLib.instance.api.crateApiWenku8MoveBookcase(
  bidList: bidList,
  fromBookcaseId: fromBookcaseId,
  toBookcaseId: toBookcaseId,
);

Future<List<SearchHistory>> searchHistories() =>
    RustLib.instance.api.crateApiWenku8SearchHistories();

Future<PageStatsNovelCover> search({
  required String searchType,
  required String searchKey,
  required int page,
}) => RustLib.instance.api.crateApiWenku8Search(
  searchType: searchType,
  searchKey: searchKey,
  page: page,
);

class PageStatsNovelCover {
  final int currentPage;
  final int maxPage;
  final List<NovelCover> records;

  const PageStatsNovelCover({
    required this.currentPage,
    required this.maxPage,
    required this.records,
  });

  static Future<PageStatsNovelCover> default_() =>
      RustLib.instance.api.crateApiWenku8PageStatsNovelCoverDefault();

  @override
  int get hashCode =>
      currentPage.hashCode ^ maxPage.hashCode ^ records.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PageStatsNovelCover &&
          runtimeType == other.runtimeType &&
          currentPage == other.currentPage &&
          maxPage == other.maxPage &&
          records == other.records;
}

class ReadingHistory {
  final String novelId;
  final String novelName;
  final String volumeId;
  final String volumeName;
  final String chapterId;
  final String chapterTitle;
  final PlatformInt64 lastReadAt;
  final int progress;
  final String cover;
  final String author;

  const ReadingHistory({
    required this.novelId,
    required this.novelName,
    required this.volumeId,
    required this.volumeName,
    required this.chapterId,
    required this.chapterTitle,
    required this.lastReadAt,
    required this.progress,
    required this.cover,
    required this.author,
  });

  @override
  int get hashCode =>
      novelId.hashCode ^
      novelName.hashCode ^
      volumeId.hashCode ^
      volumeName.hashCode ^
      chapterId.hashCode ^
      chapterTitle.hashCode ^
      lastReadAt.hashCode ^
      progress.hashCode ^
      cover.hashCode ^
      author.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReadingHistory &&
          runtimeType == other.runtimeType &&
          novelId == other.novelId &&
          novelName == other.novelName &&
          volumeId == other.volumeId &&
          volumeName == other.volumeName &&
          chapterId == other.chapterId &&
          chapterTitle == other.chapterTitle &&
          lastReadAt == other.lastReadAt &&
          progress == other.progress &&
          cover == other.cover &&
          author == other.author;
}

class SearchHistory {
  final String searchType;
  final String searchKey;
  final PlatformInt64 searchTime;

  const SearchHistory({
    required this.searchType,
    required this.searchKey,
    required this.searchTime,
  });

  @override
  int get hashCode =>
      searchType.hashCode ^ searchKey.hashCode ^ searchTime.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SearchHistory &&
          runtimeType == other.runtimeType &&
          searchType == other.searchType &&
          searchKey == other.searchKey &&
          searchTime == other.searchTime;
}
